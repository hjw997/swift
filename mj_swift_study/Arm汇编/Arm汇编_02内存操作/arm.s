//
//  arm.s
//  Arm汇编_02内存操作
//
//  Created by whj on 2024/8/11.
//

.text
.global _test


_test:
//下面这种是操作寄存器:
;mov x1,#0x8 // mov 指令只能操作寄存器
///我们软件开发不能局限操作寄存器 ,如何操作内存呢?  PS : 内存寻址 加[]

//----------------------2.str stur ,stp 指令,往内存中写入数据 --------------------------

str w0,[x1] //以将 w0的中的4个字节写入到 x1 地址开始的 4个字节中.

str x0,[x1] //以将 x0的中的8个字节写入到 x1 地址开始的 8个字节中.

// 因为 右边 [x1] 是 内存寻址,所以也可以和读内存一样 可以 [基地址 + 偏移量] 等等如下.
str w0,[x1,#0x5]  // w0 -> x1+0x5 内存地址开始的4个字节中.
str w0,[x1,#0x5]! // 加感叹号写内存完后 再 把x1 = x1 + 0x5  .

//所以 如果是偏移为负数
stur w0,[x1,#-0x5]

//stp p 一对寄存器
stp w0,w1,[x1,#0x5] //w0 中的4个字节写入 x1 + #0x5 为地址的4个字节, 再将 w1中的4个字节写入 后4个字节中.

//答疑1: 不能用 mov 读写 内存,mov 指令只能操作寄存器
//答疑2: str 不能 将立即数 写入 内存, 比如 str #0x5,[x1] 不可以,因为 立即数 不能判断出要覆盖 几个字节.


//---------------------1. ldr ,ldur ,ldp  读取内存------------------------

//5. ldp (p是pair 的简称  一对的意思)
// 读内存地址开始的地方开始,取4个字节到w0, 读完4个字节后,再从后面的地址开始 读取4个字节到 w1 寄存器.
ldp w0,w1,[x1,0x5]

//4 ldur 如果偏移的地址为负数 就用 带u 的.
ldur w0,[x1,#-0x5]

//3.ldr指令,从内存中读取数据
//加了!表示: x1+0x4 作为操作数的地址, 从该地址读取4个字节 放到w0寄存器(x是读64位,8字节)
//          然后 x1 = x1+0x4
ldr w0,[x1,0x4]!

//2.ldr 指令 基地址寻址 (在基地址附近去读取内存数据)
//x1+0x4 的结果当做一个地址值,从这个地址开始取读取 4字节到 w0.(因为是w 32位寄存器,如果x是64位8字节)
ldr w0,[x1,#0x4]

///1. ldr 指令
;ldr 指令:从内存中读取数据 放到寄存器
;ldr x0,内存  从哪个内存中读取放到寄存器x0 中.
;ldr x0,[x1] 找到寄存器x1中存储的地址值对应的内存, 读取里面的数据到 x0
//为了能让 x1中寸一个真实的地址 我们先写个 变量 ,然后读取 a的地址,在寄存器操作:
ldr x0,[x1]
ret

